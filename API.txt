// $Id$

SYNTAX
------

  # drush [options] <service> <action> ...
  # drush [options] <alias> ...

TERMINOLOGY
-----------
At present drush uses the following terminology:

* DRUSH COMMAND
  the combination of the service and action name parameters, or
  alternatively the alias parameter, given to drush on the command line (see
  Syntax, above).

* DRUSH SERVICE
  a collection of related drush actions. A number of built-in services,
  mostly relating to the Drupal core, are provided with drush. Third-party
  Drupal modules can provide additional services. A drush service is
  distributed as a file with the .drush suffix.

* DRUSH ACTION
  an individual, specific command or task provided by a drush service. Each
  drush action is implemented by means of a PHP function in a .drush file.
  Any command line parameters given after the action name are passed as
  arguments to the function in the same order as given on the command line.

* DRUSH ALIAS
  a shorter or alternate name for a drush action. drush services can provide
  aliases via calls to the drush_alias() API function. The alias mechanism
  can also be used to extend or override any built-in drush action.

NAMESPACES
----------
All drush-related functions live in the PHP `drush_' top-level namespace
(that is, they all have this as their prefix -- this has nothing to do with
PHP5 namespaces ;-)).

The first-level namespace `drush_*()' is reserved solely for the drush core
itself, and includes functions such as the Drupal hook implementations
(drush_help(), drush_cron(), etc.), as well the exported drush API that is
made available for writing drush services (e.g. drush_register(),
drush_alias(), drush_print(), and so on). As this is hotly-contested piece
of real estate, services MUST NOT define functions on this level.

The second-level namespace `drush_*_*()' is intended for the implementations
of the specific actions provided by drush services: the action name is always
qualified by the service name, and the function names map into drush
commands in a straightforward way:

  function drush_drupal_version()
    => drush command: `drupal version'

  function drush_generate_password($length = 10)
    => drush command: `generate password [length]'

  function drush_module_list_outdated()
    => drush command: `module list outdated'

AN EXAMPLE: THE ECHO SERVICE
----------------------------
Here's a very simple example of providing a third-party drush service, in
this case for a hypothetical Drupal module called `echo':

  modules/echo/echo.drush:

    <?php
    /**
     * @file
     * Example drush actions for the imaginary echo module.
     */
    
    /**
     * Echoes the provided text argument back at the user.
     */
    function drush_echo_text($text) {
      print $text . "\n";
    }
    
    // Add shorter form so that 'drush echo' == 'drush echo text'
    drush_alias('echo', array('echo', 'text'));
    
    ?>

The .drush file will be automatically found by drush upon startup, so we can
proceed directly to trying out our new action. First, we should verify that
the `drush help' command includes a line for our addition:

  # drush help | grep echo
    echo        Echoes the provided text argument back at the user.

That looks good (and note the automagically included PHPDoc description), so
let's proceed to using the echo facility:

  # drush echo 'hello world!'
    hello world!

For more advanced examples, please refer to the built-in drush services
supplied in the modules/drush/services/ directory.

SIMULATED ACTIONS
-----------------
Services SHOULD make sure that all operations that cause side effects (e.g.
modify or delete objects in the database, or execute external programs) go
through the wrapper function drush_op():

  BAD:  variable_set('my_var', $value);
  GOOD: drush_op('variable_set', 'my_var', $value);

  BAD:  system($cmd);
  GOOD: drush_op('system', $cmd);

Using this technique consistently for every mutative, destructive or
external operation ensures that:

* The operations can be supressed when running in simulation mode (i.e.
  when using the `-s' command line argument to drush).

* The operations can be recorded, meaning drush can be used to create
  pre-recorded scripts that can easily be played back on another system.
  (Note that this is only a preliminary notion and hasn't yet been
  actually implemented.)

COMMAND DISPATCH
----------------
TODO

DRUSH BOOTSTRAP
---------------
TODO

MAGIC GOES HERE
---------------
To reduce RSI risk and encourage well-documented code, drush contains the
following bits of implicit magic:

* The PHPDoc @file block comment is used as the description for a drush
  service (i.e. a file with the .drush suffix).
* The PHPDoc block comment preceding the function declaration of a drush
  action is used as the description for that action.

NOTE: these features rely on PHP's tokenizer, which could possibly be
problematic in situations where the entire Drupal code base has been
encrypted or compressed with some third-party utility, and tokenizing isn't
possible. This should only affect actions that actually make use of these
reflective features, the primary example being 'drush help'.
